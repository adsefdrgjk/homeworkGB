# GIT для чайников или кофеварок

Большинство хороших программистов делают свою работу не потому, что ожидают оплаты или признания, а потому что получают удовольствие от программирования.

> Linus Torvalds (создатель Git и Linux)

Чтобы работа с кодом действительно доставляла удовольствие, а не головную боль, работу с контролем версий можно переложить на Git.

## Основы работы c Git

### Настройка Git

Открываем терминал и делаем самые важные настройки: наше имя пользователя и адрес электронной почты.
`
git config --global user.name "My Name"
git config --global user.email myEmail@example.com
`

Для удобства и легкости зрительного восприятия, некоторые группы команд в Гит можно выделить цветом, для этого нужно прописать в консоли:
`
git config --global color.ui true
git config --global color.status auto
git config --global color.branch auto
`
Если вы не до конца настроили систему для работы, в начале своего пути - не беда. Git всегда подскажет разработчику, если тот запутался, например:

- Команда git --help - выводит общую документацию по git

- Если введем git log --help - он предоставит нам документацию по какой-то определенной команде (в данном случае это - log)

- Если вы вдруг сделали опечатку - система подскажет вам нужную команду

- После выполнения любой команды - отчитается о том, что вы натворили

Также Гит прогнозирует дальнейшие варианты развития событий и всегда направит разработчика, не знающего, куда двигаться дальше.

### Создание нового репозитория

Чтобы создать новый репозиторий, нам нужно открыть терминал, зайти в папку нашего проекта и выполнить команду init. Это включит приложение в этой конкретной папке и создаст скрытую директорию .git, где будет храниться история репозитория и настройки.  
Создайте на рабочем столе папку под названием git_exercise. Для этого в окне терминала введите:
`
mkdir Desktop/git_exercise/
cd Desktop/git_exercise/
git init
`
Это значит, что наш репозиторий был успешно создан, но пока что пуст. Теперь создайте текстовый файл под названием ReadMe.md и сохраните его в директории git_exercise.

### Определение состояния

status — это еще одна важнейшая команда, которая показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее. Запуск git status на нашем свежесозданном репозитории должен выдать:
`
git status
On branch master
Initial commit Untracked files: (use "git add ..." to include in what will be committed) ReadMe.md
`
Сообщение говорит о том, что файл ReadMe.md неотслеживаемый. Это значит, что файл новый и система еще не знает, нужно ли следить за изменениями в файле или его можно просто игнорировать. Для того, чтобы начать отслеживать новый файл, нужно его специальным образом объявить.

### Подготовка файла

В нашем случае у нас только один файл, так что добавим его:
`
git add ReadMe.md
`
Если нам нужно добавить все, что находится в директории, мы можем использовать
`
git add -A
`
Проверим статус снова, на этот раз мы должны получить другой ответ:
`
git status
On branch master
Initial commit
Changes to be committed: (use "git rm --cached ..." to unstage)
 new file: ReadMe.md
`
Файл готов к коммиту. Сообщение о состоянии также говорит нам о том, какие изменения относительно файла были проведены в области подготовки — в данном случае это новый файл, но файлы могут быть модифицированы или удалены.

Файл готов к коммиту. Сообщение о состоянии также говорит нам о том, какие изменения относительно файла были проведены в области подготовки — в данном случае это новый файл, но файлы могут быть модифицированы или удалены.

### Фиксация изменений в файле

#### Создание коммита

Представим, что нам нужно добавить пару новых блоков. Для сохранения изменений, их необходимо закоммитить. Но сначала, мы должны обозначить эти файлы для Гита, при помощи команды git add, добавляющей (или подготавливающей) их к коммиту. Добавлять их можно по отдельности:
`
git add index.html
git add css/style.css
`
или вместе - всё сразу:
`
git add .
`
Конечно добавлять всё сразу удобнее, чем прописывать каждую позицию отдельно. Однако, тут надо быть внимательным, чтобы не добавить по ошибке ненужные элементы. Если же такое произошло изъять оттуда ошибочный файл можно при помощи команды
`
git reset
`
Теперь создадим непосредственно сам коммит
`
git commit -m 'Add some explanation'
`
Флажок -m задаст commit message - комментарий разработчика. Он необходим для описания закоммиченных изменений. И здесь работает золотое правило всех комментариев в коде: «Максимально ясно, просто и содержательно обозначь написанное!»

#### Посмотреть коммиты

Для просмотра все выполненных фиксаций можно воспользоваться историей коммитов. Она содержит сведения о каждом проведенном коммите проекта. Запросить ее можно при помощи команды:
`
git log
`
В ней содержится вся информация о каждом отдельном коммите, с указанием его хэша, автора, списка изменений и даты, когда они были сделаны. Отследить интересующие вас операции в списке изменений, можно по хэшу коммита, при помощи команды git show :
`
git show hash_commit
`
Ну а если вдруг нам нужно переделать commit message и внести туда новый комментарий, можно написать следующую конструкцию:
`
git commit --amend -m 'Новый комментарий'
`
В данном случае сообщение последнего коммита перезапишется. Но злоупотреблять этим не стоит, поскольку эта операция опасная и лучше ее делать до отправки коммита на сервер.

#### Отслеживание изменений, сделанных в коммитах

У каждого коммита есть свой уникальный идентификатор в виде строки цифр и букв. Чтобы просмотреть список всех коммитов и их идентификаторов, можно использовать команду log:
`
git log
commit ba25c0ff30e1b2f0259157b42b9f8f5d174d80d7
Author: Somebody
Date: Mon May 30  17:15:28  2023 +0300
New feature complete commit b10cc1238e355c02a044ef9f9860811ff605c9b4
Author: Somebody
Date: Mon May 30  16:30:04  2023 +0300
Added content to ReadMe.md commit 09bd8cc171d7084e78e4d118a2346b7487dca059
Author: Somebody
Date: Sat May 28  17:52:14  2023 +0300
Initial commit
`
Как вы можете заметить, идентификаторы довольно длинные, но для работы с ними не обязательно копировать их целиком — первых нескольких символов будет вполне достаточно. Чтобы посмотреть, что нового появилось в коммите, мы можем воспользоваться командой show
`
git show
b10cc123 commit b10cc1238e355c02a044ef9f9860811ff605c9b4
Author: Somebody
Date: Mon May 30 16:30:04 2016 +0300
Added content to ReadMe.md
diff --git a/ReadMe.md b/ReadMe.md
index e69de29..b546a21 100644
--- a/ReadMe.md
+++ b/ReadMe.md @@ -0,0 +1 @@
+Nice soft, isn't it?
`
Чтобы увидеть разницу между двумя коммитами, используется команда diff (с указанием промежутка между коммитами):

#### Возвращение файла к предыдущему состоянию

Гит позволяет вернуть выбранный файл к состоянию на момент определенного коммита. Это делается командой checkout, она также может быть использована для переключения между ветками.
`
git checkout
`

#### Исправление коммита

Если вы опечатались в комментарии или забыли добавить файл и заметили это сразу после того, как закоммитили изменения, вы легко можете это поправить при помощи commit —amend. Эта команда добавит все из последнего коммита в область подготовленных файлов и попытается сделать новый коммит. Это дает вам возможность поправить комментарий или добавить недостающие файлы в область подготовленных файлов.  
Для более сложных исправлений, например, не в последнем коммите или если вы успели отправить изменения на сервер, нужно использовать revert. Эта команда создаст коммит, отменяющий изменения, совершенные в коммите с заданным идентификатором.  
`
git revert HEAD
git revert b10cc123
`
Самый последний коммит может быть доступен по алиасу HEAD
Для остальных будем использовать идентификаторы
При отмене старых коммитов нужно быть готовым к тому, что возникнут конфликты. Такое случается, если файл был изменен еще одним, более новым коммитом. И теперь git не может найти строчки, состояние которых нужно откатить, так как они больше не существуют.

вот тут будет немного проблем с мерджем бранчей
Самый последний коммит может быть доступен по алиасу HEAD
Для остальных будем использовать идентификаторы
При отмене старых коммитов нужно быть готовым к тому, что возникнут конфликты. Такое случается, если файл был изменен еще одним, более новым коммитом. И теперь git не может найти строчки, состояние которых нужно откатить, так как они больше не существуют.

### Настройка .gitignore

В большинстве проектов есть файлы или целые директории, в которые мы не хотим (и, скорее всего, не захотим) коммитить. Мы можем удостовериться, что они случайно не попадут в git add -A при помощи файла .gitignore

1. Создайте вручную файл под названием .gitignore и сохраните его в директорию проекта.
2. Внутри файла перечислите названия файлов/папок, которые нужно игнорировать, каждый с новой строки.
3. Файл .gitignore должен быть добавлен, закоммичен и отправлен на сервер, как любой другой файл в проекте.

Вот хорошие примеры файлов, которые нужно игнорировать:

- Логи
- Артефакты систем сборки
- Папки node_modules в проектах node.js
- Папки, созданные IDE, например, Netbeans или IntelliJ
- Разнообразные заметки разработчика.

## Ветвление

### Создание новой ветки

Основная ветка в каждом репозитории называется master. Чтобы создать еще одну ветку, используем команду
`
branch namenewbranch
`
Это создаст новую ветку, пока что точную копию ветки master.

### Переключение между ветками

Сейчас, если мы запустим branch, мы увидим две доступные опции:
`
git branch
amazing_new_feature

\* master
`
master — это активная ветка, она помечена звездочкой. Но мы хотим работать с нашей “новой потрясающей фичей”, так что нам понадобится переключиться на другую ветку. Для этого воспользуемся командой checkout, она принимает один параметр — имя ветки, на которую необходимо переключиться.
`
git checkout amazing_new_feature
`
В Git ветка — это отдельная линия разработки. Git checkout позволяет нам переключаться как между удаленными, так и меду локальными ветками. Это один из способов получить доступ к работе коллеги или соавтора, обеспечивающий более высокую продуктивность совместной работы. Однако тут надо помнить, что пока вы не закомитили изменения, вы не сможете переключиться на другую ветку. В такой ситуации нужно либо сделать коммит, либо отложить его, при помощи команды git stash, добавляющей текущие незакоммиченные изменения в стек изменений и сбрасывающей рабочую копию до HEAD'а репозитория.

